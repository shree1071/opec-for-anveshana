import { useRef as e, useState as n, useEffect as l } from "react";
import { Conversation as r } from "@elevenlabs/client";
export { postOverallFeedback } from "@elevenlabs/client";
function u() {
  return (
    (u = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var n = 1; n < arguments.length; n++) {
            var l = arguments[n];
            for (var r in l) ({}).hasOwnProperty.call(l, r) && (e[r] = l[r]);
          }
          return e;
        }),
    u.apply(null, arguments)
  );
}
const t = ["micMuted", "volume", "serverLocation"];
function o(e = "us") {
  switch (e) {
    case "eu-residency":
    case "in-residency":
    case "us":
    case "global":
      return e;
    default:
      return (
        console.warn(
          `[ConversationalAI] Invalid server-location: ${e}. Defaulting to "us"`
        ),
        "us"
      );
  }
}
function i(e) {
  return {
    us: "wss://api.elevenlabs.io",
    "eu-residency": "wss://api.eu.residency.elevenlabs.io",
    "in-residency": "wss://api.in.residency.elevenlabs.io",
    global: "wss://api.elevenlabs.io",
  }[e];
}
function s(s = {}) {
  const { micMuted: a, volume: c, serverLocation: d } = s,
    v = (function (e, n) {
      if (null == e) return {};
      var l = {};
      for (var r in e)
        if ({}.hasOwnProperty.call(e, r)) {
          if (-1 !== n.indexOf(r)) continue;
          l[r] = e[r];
        }
      return l;
    })(s, t),
    g = e(null),
    p = e(null),
    [m, y] = n("disconnected"),
    [f, b] = n(!1),
    [C, M] = n("listening");
  return (
    l(() => {
      var e;
      void 0 !== a &&
        (null == g || null == (e = g.current) || e.setMicMuted(a));
    }, [a]),
    l(() => {
      var e;
      void 0 !== c &&
        (null == g || null == (e = g.current) || e.setVolume({ volume: c }));
    }, [c]),
    l(
      () => () => {
        var e;
        null == (e = g.current) || e.endSession();
      },
      []
    ),
    {
      startSession: async e => {
        var n;
        if (null != (n = g.current) && n.isOpen()) return g.current.getId();
        if (p.current) return (await p.current).getId();
        try {
          var l, t, s, m, f, C, w, D, I, O;
          const n = i(o((null == e ? void 0 : e.serverLocation) || d));
          return (
            (p.current = r.startSession(
              u({}, null != v ? v : {}, null != e ? e : {}, {
                origin: n,
                overrides: u(
                  {},
                  null != (l = null == v ? void 0 : v.overrides) ? l : {},
                  null != (t = null == e ? void 0 : e.overrides) ? t : {},
                  {
                    client: u(
                      {},
                      null !=
                        (s =
                          null == v || null == (m = v.overrides)
                            ? void 0
                            : m.client)
                        ? s
                        : {},
                      null !=
                        (f =
                          null == e || null == (C = e.overrides)
                            ? void 0
                            : C.client)
                        ? f
                        : {},
                      {
                        source:
                          (null == e ||
                          null == (w = e.overrides) ||
                          null == (w = w.client)
                            ? void 0
                            : w.source) ||
                          (null == v ||
                          null == (D = v.overrides) ||
                          null == (D = D.client)
                            ? void 0
                            : D.source) ||
                          "react_sdk",
                        version:
                          (null == e ||
                          null == (I = e.overrides) ||
                          null == (I = I.client)
                            ? void 0
                            : I.version) ||
                          (null == v ||
                          null == (O = v.overrides) ||
                          null == (O = O.client)
                            ? void 0
                            : O.version) ||
                          "0.4.3",
                      }
                    ),
                  }
                ),
                onConnect:
                  (null == e ? void 0 : e.onConnect) ||
                  (null == v ? void 0 : v.onConnect),
                onDisconnect:
                  (null == e ? void 0 : e.onDisconnect) ||
                  (null == v ? void 0 : v.onDisconnect),
                onError:
                  (null == e ? void 0 : e.onError) ||
                  (null == v ? void 0 : v.onError),
                onMessage:
                  (null == e ? void 0 : e.onMessage) ||
                  (null == v ? void 0 : v.onMessage),
                onAudio:
                  (null == e ? void 0 : e.onAudio) ||
                  (null == v ? void 0 : v.onAudio),
                onDebug:
                  (null == e ? void 0 : e.onDebug) ||
                  (null == v ? void 0 : v.onDebug),
                onUnhandledClientToolCall:
                  (null == e ? void 0 : e.onUnhandledClientToolCall) ||
                  (null == v ? void 0 : v.onUnhandledClientToolCall),
                onModeChange: ({ mode: e }) => {
                  M(e);
                },
                onStatusChange: ({ status: e }) => {
                  y(e);
                },
                onCanSendFeedbackChange: ({ canSendFeedback: e }) => {
                  b(e);
                },
              })
            )),
            (g.current = await p.current),
            void 0 !== a && g.current.setMicMuted(a),
            void 0 !== c && g.current.setVolume({ volume: c }),
            g.current.getId()
          );
        } finally {
          p.current = null;
        }
      },
      endSession: async () => {
        const e = g.current;
        ((g.current = null), await (null == e ? void 0 : e.endSession()));
      },
      setVolume: ({ volume: e }) => {
        var n;
        null == (n = g.current) || n.setVolume({ volume: e });
      },
      getInputByteFrequencyData: () => {
        var e;
        return null == (e = g.current) ? void 0 : e.getInputByteFrequencyData();
      },
      getOutputByteFrequencyData: () => {
        var e;
        return null == (e = g.current)
          ? void 0
          : e.getOutputByteFrequencyData();
      },
      getInputVolume: () => {
        var e, n;
        return null !=
          (e = null == (n = g.current) ? void 0 : n.getInputVolume())
          ? e
          : 0;
      },
      getOutputVolume: () => {
        var e, n;
        return null !=
          (e = null == (n = g.current) ? void 0 : n.getOutputVolume())
          ? e
          : 0;
      },
      sendFeedback: e => {
        var n;
        null == (n = g.current) || n.sendFeedback(e);
      },
      getId: () => {
        var e;
        return null == (e = g.current) ? void 0 : e.getId();
      },
      sendContextualUpdate: e => {
        var n;
        null == (n = g.current) || n.sendContextualUpdate(e);
      },
      sendUserMessage: e => {
        var n;
        null == (n = g.current) || n.sendUserMessage(e);
      },
      sendUserActivity: () => {
        var e;
        null == (e = g.current) || e.sendUserActivity();
      },
      sendMCPToolApprovalResult: (e, n) => {
        var l;
        null == (l = g.current) || l.sendMCPToolApprovalResult(e, n);
      },
      status: m,
      canSendFeedback: f,
      micMuted: a,
      isSpeaking: "speaking" === C,
    }
  );
}
export { i as getOriginForLocation, o as parseLocation, s as useConversation };
//# sourceMappingURL=lib.modern.js.map
